[[_ugtst_fixture-scripts_api-and-usage]]
= API and Usage
:Notice: Licensed to the Apache Software Foundation (ASF) under one or more contributor license agreements. See the NOTICE file distributed with this work for additional information regarding copyright ownership. The ASF licenses this file to you under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at. http://www.apache.org/licenses/LICENSE-2.0 . Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR  CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.
:_basedir: ../
:_imagesdir: images/


There are two parts to using fixture scripts: the `FixtureScripts` domain service class, and the `FixtureScript` view model class:

* The role of the `FixtureScripts` domain service is to locate all fixture scripts from the classpath and to let them be invoked, either from an integration test/BDD spec or from the UI of your Isis app.

* The role of `FixtureScript` meanwhile is to subclass for each of the scenarios that you want to define.  You can also subclass from `FixtureScript` to create helpers; more on this below.

Let's look at `FixtureScripts` domain service in more detail first.

== `FixtureScripts`

There are two ways in which you can provide a `FixtureScripts` service.

The original (pre-1.9.0) approach is to subclass subclass `FixtureScripts` domain service, with your subclass specifying which package to search for.  Various other settings can also be provided, and - being a custom class - you can also add in additional actions.  A common example is to provide a "one-shot" action to recreate a standard demo set of objects.

As of 1.9.0 there is an alternative design.  Instead of subclassing `FixtureScripts` you instead implement the xref:rgsvc.adoc#_rgsvc_spi_FixtureScriptsSpecificationProvider[`FixtureScriptsSpecificationProvider`] SPI.  (As its name suggests), this provides a `FixtureScriptsSpecification` object that contains the same information as would otherwise have been in the `FixtureScripts` subclass.

The actual implementation of the `FixtureScripts` service is then provided by the framework itself, namely the xref:rgsvc.adoc#_rgsvc_api_FixtureScriptsDefault[`FixtureScriptsDefault`] domain service, annotated to be rendered on the secondary "Prototyping" menu.  This uses the `FixtureScriptsSpecificationProvider` to adjust itself accordinly.

For example, here's the `FixtureScriptsSpecificationProvider` service that's generated by the xref:ugfun.adoc#_ugfun_getting-started_simpleapp-archetype[SimpleApp archetype]:

[source,java]
----
@DomainService(nature = NatureOfService.DOMAIN)
public class DomainAppFixturesProvider implements FixtureScriptsSpecificationProvider {
    @Override
    public FixtureScriptsSpecification getSpecification() {
        return FixtureScriptsSpecification
                .builder(DomainAppFixturesProvider.class)                                       // <1>
                .with(FixtureScripts.MultipleExecutionStrategy.EXECUTE)                         // <2>
                .withRunScriptDefault(RecreateSimpleObjects.class)                              // <3>
                .withRunScriptDropDown(FixtureScriptsSpecification.DropDownPolicy.CHOICES)      // <4>
                .withRecreate(RecreateSimpleObjects.class)                                      // <5>
                .build();
    }
}
----
<1> search for all fixture scripts under the package containing this class
<2> if the same fixture script (class) is encountered more than once, then run anyway; more on this in xref:ugtst.adoc#_ugtst_fixture-scripts_api-and-usage_organizing[Organizing Fixture scripts]], below.
<3> specify the fixture script class to provide as the default for the service's "run fixture script" action
<4> whether the service's "run fixture script" action should display other fixture scripts using a choices drop down or (if there are very many of them) using an auto-complete
<5> if present, enables a "recreate objects and return first" action to be displayed in the UI


The benefit of this design - decoupling the responsibilities of the superclass and the subclass - is that it ensures that there is always an instance of `FixtureScripts` available, even if the application itself doesn't provide one.  Some of the (non-ASF) link:http://isisaddons.org[Isis Addons] modules (eg http://github.com/isisaddons/isis-module-security[Isis addons' security] module) expect there to be a `FixtureScripts` service for seeding data, which has caused some confusion.

By way of comparison, if using the older pre-1.9.0 approach then you would create a subclass:

[source,java]
----
@DomainService
@DomainServiceLayout(
        menuBar = DomainServiceLayout.MenuBar.SECONDARY,           // <1>
        named="Prototyping",                                       // <2>
        menuOrder = "500"
)
public class DomainAppFixturesService extends FixtureScripts {     // <3>
    public DomainAppFixturesService() {
        super(
            "domainapp",                                           // <4>
            MultipleExecutionStrategy.EXECUTE);                    // <5>
    }
    @Override
    public FixtureScript default0RunFixtureScript() {
        return findFixtureScriptFor(RecreateSimpleObjects.class);  // <6>
    }
    @Override
    public List<FixtureScript> choices0RunFixtureScript() {        // <7>
        return super.choices0RunFixtureScript();
    }
}
----
<1> in the UI, render the on the right hand side (secondary) menu bar...
<2> ... under the "Prototyping" menu
<3> inherit from `org.apache.isis.applib.fixturescripts.FixtureScripts`
<4> search for all fixture scripts under the "domainapp" package; in your code this would probably be "com.mycompany.myapp" or similar
<5> if the same fixture script (class) is encountered more than once, then run anyway; more on this in xref:ugtst.adoc#_ugtst_fixture-scripts_api-and-usage_organizing[Organizing Fixture scripts]], below.
<6> (optional) specify a default fixture script to run, in this case `RecreateSimpleObjects` fixture script (see below)
<7> make all fixture scripts found available as a drop-down (by increasing the visibility of this method to `public`)

This isn't quite equivalent; you would need to write additional code to support the "recreate objects and return first" action, for example.

Either way, here's how the domain service looks like in the UI:

image::{_imagesdir}testing/fixture-scripts/prototyping-menu.png[width="700px",link="{_imagesdir}testing/fixture-scripts/prototyping-menu.png"]


and here's what the `runFixtureScript` action prompt looks like:

image::{_imagesdir}testing/fixture-scripts/prompt.png[width="700px",link="{_imagesdir}testing/fixture-scripts/prompt.png"]


when this is executed, the resultant objects (actually, instances of FixtureResult`) are shown in the UI:

image::{_imagesdir}testing/fixture-scripts/result-list.png[width="700px",link="{_imagesdir}testing/fixture-scripts/result-list.png"]



If you had defined many fixture scripts then a drop-down might become unwieldy, in which case your code would probably override the `autoComplete...())` instead:

[source,java]
----
    @Override
    public List<FixtureScript> autoComplete0RunFixtureScript(final @MinLength(1) String searchArg) {
        return super.autoComplete0RunFixtureScript(searchArg);
    }

----

You are free, of course, to add additional "convenience" actions into it if you wish for the most commonly used/demo'd setups ; you'll find that the xref:ugfun.adoc#_ugfun_getting-started_simpleapp-archetype[SimpleApp archetype] adds this additional action:

[source,java]
----
    @Action(
            restrictTo = RestrictTo.PROTOTYPING
    )
    @ActionLayout(
            cssClassFa="fa fa-refresh"
    )
    @MemberOrder(sequence="20")
    public Object recreateObjectsAndReturnFirst() {
        final List<FixtureResult> run = findFixtureScriptFor(RecreateSimpleObjects.class).run(null);
        return run.get(0).getObject();
    }
----

Let's now look at the `FixtureScript` class, where there's a bit more going on.




== `FixtureScript`

A fixture script is ultimately just a block of code that can be executed, so it's up to you how you implement it to set up the system.  However, we strongly recommend that you use it to invoke actions on business objects, in essence to replay what a real-life user would have done.  That way, the fixture script will remain valid even if the underlying implementation of the system changes in the future.

Here's the `RecreateSimpleObjects` fixture script from the xref:ugfun.adoc#_ugfun_getting-started_simpleapp-archetype[SimpleApp archetype]:

[source,java]
----
public class RecreateSimpleObjects extends FixtureScript {                   // <1>

    public final List<String> NAMES = Collections.unmodifiableList(Arrays.asList(
            "Foo", "Bar", "Baz", "Frodo", "Froyo",
            "Fizz", "Bip", "Bop", "Bang", "Boo"));                           // <2>
    public RecreateSimpleObjects() {
        withDiscoverability(Discoverability.DISCOVERABLE);                   // <3>
    }
    private Integer number;                                                  // <4>
    public Integer getNumber() { return number; }
    public RecreateSimpleObjects setNumber(final Integer number) {
        this.number = number;
        return this;
    }
    private final List<SimpleObject> simpleObjects = Lists.newArrayList();   // <5>
    public List<SimpleObject> getSimpleObjects() {
        return simpleObjects;
    }
    @Override
    protected void execute(final ExecutionContext ec) {          // <6>
        // defaults
        final int number = defaultParam("number", ec, 3);        // <7>
        // validate
        if(number < 0 || number > NAMES.size()) {
            throw new IllegalArgumentException(
                String.format("number must be in range [0,%d)", NAMES.size()));
        }
        // execute
        ec.executeChild(this, new SimpleObjectsTearDown());      // <8>
        for (int i = 0; i < number; i++) {
            final SimpleObjectCreate fs =
                new SimpleObjectCreate().setName(NAMES.get(i));
            ec.executeChild(this, fs.getName(), fs);             // <9>
            simpleObjects.add(fs.getSimpleObject());             // <10>
        }
    }
}
----
<1> inherit from `org.apache.isis.applib.fixturescripts.FixtureScript`
<2> a hard-coded list of values for the names.  Note that the http://github.com/isisaddons/isis-module-fakedata[Isis addons' fakedata] module (non-ASF) could also have been used
<3> whether the script is "discoverable"; in other words whether it should be rendered in the drop-down by the `FixtureScripts` service
<4> input property: the number of objects to create, up to 10; for the calling test to specify, but note this is optional and has a default (see below).  It's important that a wrapper class is used (ie `java.lang.Integer`, not `int`)
<5> output property: the generated list of objects, for the calling test to grab
<6> the mandatory execute(...) API
<7> the `defaultParam(...)` (inherited from `FixtureScript`) will default the `number` property (using Java's Reflection API) if none was specified
<8> call another fixture script (`SimpleObjectsTearDown`) using the provided `ExecutionContext`.  Note that although the fixture script is a view model, it's fine to simply instantiate it (rather than using `DomainObjectContainer#newTransientInstance(...)`).
<9> calling another fixture script (`SimpleObjectCreate`) using the provided `ExecutionContext`
<10> adding the created object to the list, for the calling object to use.


Because this script has exposed a "number" property, it's possible to set this from within the UI.  For example:

image::{_imagesdir}testing/fixture-scripts/prompt.png[width="700px"]


When this is executed, the framework will parse the text and attempt to reflectively set the corresponding properties on the fixture result.  So, in this case, when the fixture script is executed we actually get 6 objects created:

image::{_imagesdir}testing/fixture-scripts/result-list.png[width="700px"]



It's commonplace for one fixture script to call another.  In the above example this script called `SimpleObjectsTearDown` and `SimpleObjectCreate`.  Let's take a quick look at `SimpleObjectCreate`:

[source,java]
----
public class SimpleObjectCreate extends FixtureScript {       // <1>

    private String name;                                      // <2>
    public String getName() { return name; }
    public SimpleObjectCreate setName(final String name) {
        this.name = name;
        return this;
    }
    private SimpleObject simpleObject;                        // <3>
    public SimpleObject getSimpleObject() {
        return simpleObject;
    }
    @Override
    protected void execute(final ExecutionContext ec) {       // <4>
        String name = checkParam("name", ec, String.class);   // <5>
        this.simpleObject = wrap(simpleObjects)               // <6>
                                .create(name);                // <7>
        ec.addResult(this, simpleObject);                     // <8>
    }
    @javax.inject.Inject
    private SimpleObjects simpleObjects;                      // <9>
}
----
<1> inherit from `org.apache.isis.applib.fixturescripts.FixtureScript`, as above
<2> input property: name of the object; this time it is required
<3> output property: the created simple object
<4> the mandatory execute(...) API
<5> the `checkParam(...)` (inherited from `FixtureScript`) will check that the "name" property has been populated (using Java's Reflection API) and throw an exception if not
<6> wrap the injected `SimpleObjects` domain service (using the xref:rgsvc.adoc#_rgsvc_api_WrapperFactory[`WrapperFactory`]) to simulate interaction through the UI...
<7> .. and actually create the object using the "create" business action of that service
<8> add the resulting object to the execution context; this makes the object available to access if run from the UI
<9> inject the domain service into the fixture script







== Using within Tests

Fixture scripts can be called from integration tests just the same way that fixture scripts can call one another.

For example, here's an integration test from the xref:ugfun.adoc#_ugfun_getting-started_simpleapp-archetype[SimpleApp archetype]:

[source,java]
----
public class SimpleObjectIntegTest extends SimpleAppIntegTest {
    @Inject
    FixtureScripts fixtureScripts;                      // <1>
    SimpleObject simpleObjectWrapped;
    @Before
    public void setUp() throws Exception {
        // given
        RecreateSimpleObjects fs =
             new RecreateSimpleObjects().setNumber(1);  // <2>
        fixtureScripts.runFixtureScript(fs, null);      // <3>

        SimpleObject simpleObjectPojo =
            fs.getSimpleObjects().get(0);               // <4>
        assertThat(simpleObjectPojo).isNotNull();

        simpleObjectWrapped = wrap(simpleObjectPojo);   // <5>
    }
    @Test
    public void accessible() throws Exception {
        // when
        final String name = simpleObjectWrapped.getName();
        // then
        assertThat(name).isEqualTo(fs.NAMES.get(0));
    }
    ...
}
----
<1> inject the `FixtureScripts` domain service (just like any other domain service)
<2> instantiate the fixture script for this test, and configure
<3> execute the fixture script
<4> obtain the object under test from the fixture
<5> wrap the object (to simulate being interacted with through the UI)




[[_ugtst_fixture-scripts_api-and-usage_organizing]]
== Organizing Fixture scripts

There are lots of ways to organize fixture scripts, but we've used them as either:

* a fairly flat style, eg as in the xref:ugfun.adoc#_ugfun_getting-started_simpleapp-archetype[SimpleApp archetype], also as in the http://github.com/isisaddons/isis-app-todoapp[Isis addons' todoapp];

* in a "composite pattern" style, eg as in the https://github.com/estatio/estatio/blob/ea20a6ce257acede50de6ce4fd2ff29713fcd689/estatioapp/fixture/src/main/java/org/estatio/fixture/invoice/InvoiceForLeaseItemTypeOfDiscountOneQuarterForOxfMiracle005.java#L66)[Estatio open source app].

These two styles are probably best illustrated with, well, some illustrations.  Here's a fixture script in the "flat" style for setting up a customer with some orders, a number of which has been placed:

image::{_imagesdir}testing/fixture-scripts/flat-1.png[width="700px",link="{_imagesdir}testing/fixture-scripts/flat-1.png"]

Notice how we have a single script that's in control of the overall process, and takes responsibility for passing data from one fixture script to the next.

Here's a similar, simpler script, from the same fictional app, to set up two customers:

image::{_imagesdir}testing/fixture-scripts/flat-2.png[width="500px",link="{_imagesdir}testing/fixture-scripts/flat-2.png"]

We can reuse the same fixture "customer" script, either calling it twice or (perhaps better) passing it an array of customer details to set up.

With the composite style, we rely on each fixture script to set up its own prerequisites.  Thus:

image::{_imagesdir}testing/fixture-scripts/composite.png[width="550px",link="{_imagesdir}testing/fixture-scripts/composite.png"]

Back in the earlier section we noted the `MultipleExecutionStrategy` setting.  We can now explain the meaning of this: the enum value of `EXECUTE` is designed for the flat style (where every fixture script will be called), whereas the enum value of `IGNORE` is designed for the composite style, and ensures that any fixture scripts visited more than once (eg TearDown) are only every executed the first time.

As already noted , the app generated by the xref:ugfun.adoc#_ugfun_getting-started_simpleapp-archetype[SimpleApp archetype] uses the flat structure, and we feel that it's a better at separating out the "how" (how we set up some graph of domain objects into a known state, eg a customer with shipped placed orders and a newly placed order) from the "what" (what data should we actually use for the customer's name, say).

The composite style tends to combine these, which one could argue does not separate responsibilities well enough.  On the other hand, one could also make an argument that the composite style is a good way to implement precanned personas, eg "Joe", the customer who has a newly placed order, from "Mary" customer who has none.


=== Further approaches

As of there are two other approaches.

The first is to take advantage of a new `MultipleExecutionStrategy`, namely `EXECUTE_ONCE_BY_VALUE`.  Under this strategy the determination as to whether to run a given fixture script is by comparing the fixture script against all others that have run.  If all fixture scripts implement value semantics, then they can effectively determine
whether they need to run or not.

This strategy was introduced in order to better support the `ExcelFixture` fixture script (provided by the
(non-ASF) http://github.com/isisaddons/isis-module-excel[Isis addons' excel] module.  The `ExcelFixture` takes an
Excel spreadsheet and loads up each row.  For those cases where we wish to ensure that the same spreadsheet is not
loaded more than once, the `IGNORE` strategy would have required that a trivial subclass of `ExcelFixture` is created
for each and every spreadsheet.  The `EXECUTE_ONCE_BY_VALUE` on the other hand delegates the determination to the
value semantics of the `ExcelFixture`, which is based on the contents of the spreadsheet.

[NOTE]
====
Note that as of `1.10.0` the `IGNORE` enum has been deprecated, replaced by `EXECUTE_ONCE_BY_CLASS`
====

The second approach is in recognition that there is, in fact, something of a design flaw with the concept of
`MultipleExecutionStrategy`: it requires that all fixture scripts being run follow the same conventions.  There's a
good argument that this shouldn't be a global "setting": the responsibility for determining whether a given fixture
script should be executed should reside not in the `FixtureScripts` service but in the `FixtureScript` itself.

Thus, the `FixtureScripts.ExecutionContext` exposes the `getPreviouslyExecuted()` method that allows the fixture
script to check for itself which fixture scripts have already been run, and act accordingly.  For this approach, the
`MultipleExecutionStrategy` should be left as simply `EXECUTE`.
