[[_ugtst_integ-test-support_bootstrapping]]
= Bootstrapping
:Notice: Licensed to the Apache Software Foundation (ASF) under one or more contributor license agreements. See the NOTICE file distributed with this work for additional information regarding copyright ownership. The ASF licenses this file to you under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at. http://www.apache.org/licenses/LICENSE-2.0 . Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR  CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.
:_basedir: ../
:_imagesdir: images/


Integration tests instantiate an Apache Isis "runtime" (as a singleton) within a JUnit test.  Because (depending on the size of your app) it takes a little time to bootstrap Apache Isis, the framework caches the runtime on a thread-local from one test to the next.

Nevertheless, we do need to bootstrap the runtime for the very first test.

As of 1.9.0 the bootstrapping of integration tests and webapps has been simplified through the xref:rgcms.adoc#_rgcms_classes_AppManifest-bootstrapping[`AppManifest`] class.  Since this isn't mandatory, for now we present both techniques.

The example code in this section is taken from the app generated by the xref:ugfun.adoc#_ugfun_getting-started_simpleapp-archetype[SimpleApp archetype].




== System Initializer

The bootstrapping itself is performed by a "system initializer" class.  This is responsible for instantiating the Apache Isis runtime, and binding it to a thread-local.

=== 1.13.0 (Improved intent)

As of `1.13.0`, the `IsisConfigurationForJdoIntegTests` (which provides a number of configuration settings specifically for running integration tests) can be removed; instead all configuration properties can be defined through the `AppManifest`:

For example:
[source,java]
----
public class DomainAppSystemInitializer {
    public static void initIsft() {
        IsisSystemForTest isft = IsisSystemForTest.getElseNull();
        if(isft == null) {
            isft = new IsisSystemForTest.Builder()
                    .withLoggingAt(org.apache.log4j.Level.INFO)
                    .with(new DomainAppAppManifest() {
                        @Override
                        public Map<String, String> getConfigurationProperties() {
                            final Map<String, String> map = Maps.newHashMap();
                            Util.withJavaxJdoRunInMemoryProperties(map);
                            Util.withDataNucleusProperties(map);
                            Util.withIsisIntegTestProperties(map);
                            return map;
                        }
                    })
                    .build();
            isft.setUpSystem();
            IsisSystemForTest.set(isft);
        }
    }
}
----

While the code is slightly longer than previously, the responsibilities for returning the configuration properties to
use for the test now reside in a single location.  The new `AppManifest.Util` class provides the helper methods to
actually add in the appropriate config properties.


=== 1.9.0 (`AppManifest`)

As of 1.9.0, the code (using `AppManifest`) is:

[source,java]
----
public class DomainAppSystemInitializer {
    public static void initIsft() {
        IsisSystemForTest isft = IsisSystemForTest.getElseNull();
        if(isft == null) {
            isft = new IsisSystemForTest.Builder()
                    .withLoggingAt(org.apache.log4j.Level.INFO)
                    .with(new DomainAppAppManifest())
                    .with(new IsisConfigurationForJdoIntegTests())
                    .build()
                    .setUpSystem();
            IsisSystemForTest.set(isft);
        }
    }
}
----

where `DomainAppAppManifest` in turn is defined as:

[source,java]
----
public class DomainAppAppManifest implements AppManifest {
    @Override
    public List<Class<?>> getModules() {
        return Arrays.asList(
                domainapp.dom.DomainAppDomainModule.class,
                domainapp.fixture.DomainAppFixtureModule.class,
                domainapp.app.DomainAppAppModule.class
        );
    }
    ...
}
----

Further details on bootstrapping with the `AppManifest` can be found in the xref:rgcms.adoc#_rgcms_classes_AppManifest-bootstrapping[reference guide].

=== 1.8.0 and earlier

Prior to 1.9.0, the services and entities had to be specified in two separate locations.  The suggested way to do this was to introduce a subclass of the `IsisSystemForTest.Builder` class:

[source,java]
----
private static class DomainAppSystemBuilder extends IsisSystemForTest.Builder {      // <1>
    public DomainAppSystemBuilder() {
        withLoggingAt(org.apache.log4j.Level.INFO);
        with(testConfiguration());
        with(new DataNucleusPersistenceMechanismInstaller());                        // <2>
        withServicesIn( "domainapp" );                                               // <3>
    }
    private static IsisConfiguration testConfiguration() {
        final IsisConfigurationForJdoIntegTests testConfiguration =
            new IsisConfigurationForJdoIntegTests();                                 // <4>
        testConfiguration.addRegisterEntitiesPackagePrefix("domainapp.dom.modules"); // <5>
        return testConfiguration;
    }
}
----
<1> subclass the framework-provided `IsisSystemForTest.Builder`.
<2> equivalent to `isis.persistor=datanucleus` in `isis.properties`
<3> specify the `isis.services` key in `isis.properties` (where "domainapp" is the base package for all classes within the app)
<4> `IsisConfigurationForJdoIntegTests` has pre-canned configuration for using an in-memory HSQLDB and other standard settings; more on this below.
<5> equivalent to `isis.persistor.datanucleus.RegisterEntities.packagePrefix` key (typically in `persistor_datanucleus.properties`)




This builder could then be used within the system initializer:

[source,java]
----
public class DomainAppSystemInitializer {
    public static void initIsft() {
        IsisSystemForTest isft = IsisSystemForTest.getElseNull();
        if(isft == null) {
            isft = new DomainAppSystemBuilder()    // <1>
                            .build()
                            .setUpSystem();
            IsisSystemForTest.set(isft);           // <2>
        }
    }
    private static class DomainAppSystemBuilder
        extends IsisSystemForTest.Builder { ... }
}
----
<1> instantiates and initializes the Apache Isis runtime (the `IsisSystemForTest` class)
<2> binds the runtime to a thread-local.



=== IsisConfigurationForJdoIntegTests

Integration tests are configured programmatically, with a default set of properties to bootstrap the JDO/DataNucleus objectstore using an HSQLDB in-memory database.

To remove a little bit of boilerplate, the `IsisConfigurationForJdoIntegTests` class (in the `org.apache.isis.objectstore.jdo.datanucleus` package) can be used to bootstrap the application.  If necessary, this class can be subclassed to override these defaults.


.Default Configuration Properties for Integration Tests
[cols="2a,1,3a", options="header"]
|===
|Property
|Value
|Description

|`isis.persistor.datanucleus.impl.` +
`javax.jdo.option.ConnectionURL`
|jdbc:hsqldb:mem:test
|JDBC URL

|`isis.persistor.datanucleus.impl.` +
`javax.jdo.option.ConnectionDriverName`
|org.hsqldb.jdbcDriver
|JDBC Driver

|`isis.persistor.datanucleus.impl.` +
`javax.jdo.option.ConnectionUserName`
|sa
|Username

|`isis.persistor.datanucleus.impl.` +
`javax.jdo.option.ConnectionPassword`
|<empty string>
|Password

|`isis.persistor.datanucleus.impl.` +
`datanucleus.schema.autoCreateAll`
|true
|Recreate DB for each test run (an in-memory database)

|`isis.persistor.datanucleus.impl.` +
`datanucleus.schema.validateAll`
|false
|Disable validations (minimize bootstrap time)

|`isis.persistor.datanucleus.impl.` +
`datanucleus.persistenceByReachabilityAtCommit`
|false
|As per WEB-INF/persistor_datanucleus.properties

|`isis.persistor.datanucleus.impl.` +
`datanucleus.identifier.case`
|MixedCase
|As per WEB-INF/persistor_datanucleus.properties

|`isis.persistor.datanucleus.impl.` +
`datanucleus.cache.level2.type`
|none
|As per WEB-INF/persistor_datanucleus.properties

|`isis.persistor.datanucleus.impl.` +
`datanucleus.cache.level2.mode`
|ENABLE_SELECTIVE
|As per WEB-INF/persistor_datanucleus.properties

|`isis.persistor.datanucleus.` +
`install-fixtures`
|true
|Automatically install any fixtures that might have been registered

|`isis.persistor.` +
`enforceSafeSemantics`
|false
|

|`isis.deploymentType`
|server_prototype
|
|===




== Abstract Class

We recommend defining a base class for all your other classes to integration classes to inherit from.  The main responsibility of this class is tocall the system initializer, described earlier.  We only need the initialization to be performed once, so this call is performed in a `@BeforeClass` hook.

The code below shows the general form:

[source,java]
----
public abstract class DomainAppIntegTest {
    @BeforeClass
    public static void initClass() {
        org.apache.log4j.PropertyConfigurator.configure("logging.properties");   // <1>
        DomainAppSystemInitializer.initIsft();                                   // <2>
        new ScenarioExecutionForIntegration();                                   // <3>
    }
}
----
<1> ensure that logging messages don't get swallowed
<2> initialize the Apache Isis runtime
<3> primarily exists to support the writing of xref:ugtst.adoc#_ugtst_bdd-spec-support[BDD specifications], but also enables finer-grained management of sessions/transactions (discussed below).


[[_ugtst_integ-test-support_bootstrapping_IntegrationTestAbstract]]
=== `IntegrationTestAbstract`

In fact, we recommend that your base class inherit from Apache Isis' `IntegrationTestAbstract` class:

[source,java]
----
public abstract class DomainAppIntegTest extends IntegrationTestAbstract {
    ...
}
----

Although not mandatory, this provides a number of helper/convenience methods and JUnit rules:

[source,java]
----
    @Rule
    public IsisTransactionRule isisTransactionRule =                         // <1>
        new IsisTransactionRule();
    @Rule
    public JUnitRuleMockery2 context =                                       // <2>
        JUnitRuleMockery2.createFor(Mode.INTERFACES_AND_CLASSES);
    @Rule
    public ExpectedException expectedExceptions =                            // <3>
        ExpectedException.none();
    @Rule
    public ExceptionRecognizerTranslate exceptionRecognizerTranslations =    // <4>
        ExceptionRecognizerTranslate.create();
----
<1> ensures an Apache Isis session/transaction running for each test
<2> sets up a JMock context (using Apache Isis' extension to JMock as described in xref:ugtst.adoc#_ugtst_unit-test-support_jmock-extensions[JMock Extensions].
<3> standard JUnit rule for writing tests that throw exceptions
<4> to capture messages that require translation, as described in xref:ugbtb.adoc#_ugbtb_i18n[i18 support].

All of these rules could be inlined in your own base class; as we say, they are a convenience.

The `IntegrationTestAbstract` also provides a number of helper/convenience methods, though most of these have been
deprecated because the functionality they expose is now readily accessible through various domain services; most
notably these are:

* xref:rgsvc.adoc#_rgsvc_api_WrapperFactory[`WrapperFactory`] +
+
to wrap objects simulating interaction through the user interface)

* xref:rgsvc.adoc#_rgsvc_api_TransactionService[`TransactionService`] +
+
most commonly used to commit changes after the fixture setup) and,

* xref:rgsvc.adoc#_rgsvc_api_SessionManagementService[`SessionManagementService`] +
+
for tests that check interactions over multiple separate sessions.


